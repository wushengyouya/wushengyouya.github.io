<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>网络 on 吴生有涯</title>
        <link>https://wushengyouya.github.io/tags/%E7%BD%91%E7%BB%9C/</link>
        <description>Recent content in 网络 on 吴生有涯</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <copyright>吴生有涯</copyright>
        <lastBuildDate>Thu, 02 Mar 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://wushengyouya.github.io/tags/%E7%BD%91%E7%BB%9C/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>计算机网络</title>
        <link>https://wushengyouya.github.io/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</link>
        <pubDate>Thu, 02 Mar 2023 00:00:00 +0000</pubDate>
        
        <guid>https://wushengyouya.github.io/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</guid>
        <description>&lt;img src="https://wushengyouya.github.io/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image.png" alt="Featured image of post 计算机网络" /&gt;&lt;h2 id=&#34;网络分层&#34;&gt;网络分层&lt;/h2&gt;
&lt;p&gt;常见的网络模型分为OSI七层模型与TCP/IP四层模型，OSI因为比较复杂实现起来麻烦，使用的不多。通常用TCP/IP
的四层网络模型。&lt;/p&gt;
&lt;h3 id=&#34;osi模型&#34;&gt;OSI模型&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;应用层&lt;/li&gt;
&lt;li&gt;表示层&lt;/li&gt;
&lt;li&gt;会话层&lt;/li&gt;
&lt;li&gt;传输层&lt;/li&gt;
&lt;li&gt;网络层&lt;/li&gt;
&lt;li&gt;数据链路层&lt;/li&gt;
&lt;li&gt;物理层&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;tcpip模型&#34;&gt;TCP/IP模型&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;应用层：HTTP  FTP GRPC&lt;/li&gt;
&lt;li&gt;传输层：TCP UDP&lt;/li&gt;
&lt;li&gt;网络层：IP&lt;/li&gt;
&lt;li&gt;网络接口层
&lt;img src=&#34;../../p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image.png&#34;
	width=&#34;1329&#34;
	height=&#34;802&#34;
	srcset=&#34;../../p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image_hue7adf6be507cc8c391e944aaaa332a2f_57263_480x0_resize_box_3.png 480w, ../../p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image_hue7adf6be507cc8c391e944aaaa332a2f_57263_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;alt text&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;165&#34;
		data-flex-basis=&#34;397px&#34;
	
&gt;
&lt;img src=&#34;../../p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-1.png&#34;
	width=&#34;602&#34;
	height=&#34;782&#34;
	srcset=&#34;../../p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-1_hudc0e10b798511b17e93072a753b6f28b_111574_480x0_resize_box_3.png 480w, ../../p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-1_hudc0e10b798511b17e93072a753b6f28b_111574_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;alt text&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;76&#34;
		data-flex-basis=&#34;184px&#34;
	
&gt;
&lt;img src=&#34;../../p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-2.png&#34;
	width=&#34;905&#34;
	height=&#34;501&#34;
	srcset=&#34;../../p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-2_hud5008bd5bcc72ce2e8ff9c4a63a3d1e8_125702_480x0_resize_box_3.png 480w, ../../p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-2_hud5008bd5bcc72ce2e8ff9c4a63a3d1e8_125702_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;alt text&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;180&#34;
		data-flex-basis=&#34;433px&#34;
	
&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;数据包封包解包流程&#34;&gt;数据包封包解包流程&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;../../p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-6.png&#34;
	width=&#34;936&#34;
	height=&#34;953&#34;
	srcset=&#34;../../p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-6_hub54d2c6e5e7d9b2472e7978642209de7_534704_480x0_resize_box_3.png 480w, ../../p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-6_hub54d2c6e5e7d9b2472e7978642209de7_534704_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;alt text&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;98&#34;
		data-flex-basis=&#34;235px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;什么是http&#34;&gt;什么是HTTP&lt;/h2&gt;
&lt;p&gt;超文本传输协议,是网络中最常见的通讯协议。基于传输层TCP协议构建的应用层协议，数据采用明文传输，安全性差。
&lt;img src=&#34;../../p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-7.png&#34;
	width=&#34;1773&#34;
	height=&#34;1847&#34;
	srcset=&#34;../../p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-7_hue8ddaaae4ad1b2b506d78b9df7ede9ed_780350_480x0_resize_box_3.png 480w, ../../p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-7_hue8ddaaae4ad1b2b506d78b9df7ede9ed_780350_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;alt text&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;95&#34;
		data-flex-basis=&#34;230px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;get-与-post&#34;&gt;Get 与 Post&lt;/h3&gt;
&lt;p&gt;「幂等」，意思是多次执行相同的操作，结果都是「相同」的。&lt;/p&gt;
&lt;p&gt;「安全」是指请求方法不会「破坏」服务器上的资源。&lt;/p&gt;
&lt;p&gt;GET:从服务器获取指定的资源，这个资源可以是静态的文本、页面、图片视频等。浏览器对URL的请求长度有限制，HTTP没有。所有来说GET请求是用长度限制的。GET请求是安全幂等的。&lt;/p&gt;
&lt;p&gt;POST:新增或提交数据。因为会修改服务器上的资源所以是不安全的，因为会多次提交数据所以是不幂等的。&lt;/p&gt;
&lt;h3 id=&#34;http-常见的状态码&#34;&gt;HTTP 常见的状态码&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;../../p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-3.png&#34;
	width=&#34;1280&#34;
	height=&#34;642&#34;
	srcset=&#34;../../p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-3_hu708f162ee7cf1d9e159d272898acaf36_449945_480x0_resize_box_3.png 480w, ../../p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-3_hu708f162ee7cf1d9e159d272898acaf36_449945_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;alt text&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;199&#34;
		data-flex-basis=&#34;478px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;http通过什么解决粘包问题的&#34;&gt;HTTP通过什么解决粘包问题的&lt;/h3&gt;
&lt;p&gt;HTTP 协议通过设置回车符、换行符作为 HTTP header 的边界，通过 Content-Length 字段作为 HTTP body 的边界，这两个方式都是为了解决“粘包”的问题。&lt;/p&gt;
&lt;h3 id=&#34;http和https有什么区别&#34;&gt;HTTP和HTTPS有什么区别&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;HTTP是超文本传输协议，信息是明文传输的，存在安全问题。HTTPS则解决HTTP不安全的问题，在TCP和HTTP网络层之间加入SSL/TLS安全协议，是得报文能够加密传输。&lt;/li&gt;
&lt;li&gt;HTTP连接建立相对简单，TCP三次握手后便可进行HTTP的报文传输。而HTTPS在TCP三次握手后还需进行SSL/TLS的握手过程，才可进行加密报文传输。&lt;/li&gt;
&lt;li&gt;两者端口不一样HTTP是80端口，HTTP是443端口。&lt;/li&gt;
&lt;li&gt;HTTPS协议需要向CA(证书权威结构)申请数字证书，来保证服务器的身份是可靠的。
&lt;img src=&#34;../../p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-4.png&#34;
	width=&#34;596&#34;
	height=&#34;275&#34;
	srcset=&#34;../../p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-4_hud3819ee1162ca798e8030c2ab8f89898_89770_480x0_resize_box_3.png 480w, ../../p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-4_hud3819ee1162ca798e8030c2ab8f89898_89770_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;alt text&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;216&#34;
		data-flex-basis=&#34;520px&#34;
	
&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;https解决了什么问题&#34;&gt;HTTPS解决了什么问题&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;窃听风险&lt;/li&gt;
&lt;li&gt;篡改风险&lt;/li&gt;
&lt;li&gt;冒充风险&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;http2改进在哪&#34;&gt;HTTP/2改进在哪&lt;/h3&gt;
&lt;p&gt;队头堵塞：
HTTP/2 是基于 TCP 协议来传输数据的，TCP 是字节流协议，TCP 层必须保证收到的字节数据是完整且连续的，这样内核才会将缓冲区里的数据返回给 HTTP 应用，那么当「前 1 个字节数据」没有到达时，后收到的字节数据只能存放在内核缓冲区里，只有等到这 1 个字节数据到达时，HTTP/2 应用层才能从内核中拿到数据，这就是 HTTP/2 队头阻塞问题。
&lt;img src=&#34;../../p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-5.png&#34;
	width=&#34;782&#34;
	height=&#34;366&#34;
	srcset=&#34;../../p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-5_hu9a7a0316661331b067029f4c838cc7e0_201332_480x0_resize_box_3.png 480w, ../../p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-5_hu9a7a0316661331b067029f4c838cc7e0_201332_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;alt text&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;213&#34;
		data-flex-basis=&#34;512px&#34;
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;兼容HTTP/1.1&lt;/li&gt;
&lt;li&gt;使用HPACK 算法压缩请求头&lt;/li&gt;
&lt;li&gt;为高频出现在头部的字符串和字段建立了一张静态表&lt;/li&gt;
&lt;li&gt;将 HTTP/1 的文本格式改成二进制格式传输数据&lt;/li&gt;
&lt;li&gt;多个 Stream 复用一条 TCP 连接，达到并发的效果，解决了 HTTP/1.1 队头阻塞的问题，提高了 HTTP 传输的吞吐量。
缺陷&lt;/li&gt;
&lt;li&gt;队头阻塞&lt;/li&gt;
&lt;li&gt;TCP 与 TLS 的握手时延迟&lt;/li&gt;
&lt;li&gt;网络迁移需要重新连接&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;http3&#34;&gt;HTTP/3&lt;/h3&gt;
&lt;p&gt;将TCP协议改成了UDP,并在UDP上开发了QUIC协议来保障数据传输的可靠性&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;无队头堵塞&lt;/li&gt;
&lt;li&gt;建立连接速度更快&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;输入网址到展示发什么了&#34;&gt;输入网址到展示发什么了&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;解析URL地址生成HTTP请求报文&lt;/li&gt;
&lt;li&gt;进行DNS域名解析获取IP。先查看缓存如果有就直接返回
没有再去hosts文件查看，如果再没没有则发送DNS请求询问本地的DNS服务器&lt;/li&gt;
&lt;li&gt;DNS获取到Ip后，就可以把HTTP协议的传输工作交给操作系统的协议栈
（HTTP是基于TCP协议传输数据前，要先进行TCP三次握手）&lt;/li&gt;
&lt;li&gt;TCP 模块在执行连接、收发、断开等各阶段操作时，都需要委托 IP 模块
将数据封装成网络包发送给通信&lt;/li&gt;
&lt;li&gt;查找mac地址，先查路由表，如果路由表没有就通过ARP协议广播查找mac地址&lt;/li&gt;
&lt;li&gt;将数据包通过网卡发送到交换机，交换机再发送到服务器&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;什么是tcp&#34;&gt;什么是TCP&lt;/h2&gt;
&lt;p&gt;TCP是面向连接的、可靠的、基于字节流的传输层通信协议&lt;/p&gt;
&lt;p&gt;TCP数据格式:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-11.png&#34;
	width=&#34;1053&#34;
	height=&#34;828&#34;
	srcset=&#34;../../p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-11_hu4c2c9b241bac8288b869a1047ce1879a_277912_480x0_resize_box_3.png 480w, ../../p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-11_hu4c2c9b241bac8288b869a1047ce1879a_277912_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;alt text&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;127&#34;
		data-flex-basis=&#34;305px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;tcp的三次握手和四次挥手&#34;&gt;TCP的三次握手和四次挥手&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;TCP三次握手中，只有第三次握手是可以携带数据的，前两次握手是不可以携带数据的&lt;/code&gt;
&lt;img src=&#34;../../p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-10.png&#34;
	width=&#34;1896&#34;
	height=&#34;695&#34;
	srcset=&#34;../../p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-10_hu95dbf7b7a2a2db93ba47892033001e1e_183157_480x0_resize_box_3.png 480w, ../../p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-10_hu95dbf7b7a2a2db93ba47892033001e1e_183157_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;alt text&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;272&#34;
		data-flex-basis=&#34;654px&#34;
	
&gt;
&lt;img src=&#34;../../p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-9.png&#34;
	width=&#34;1568&#34;
	height=&#34;690&#34;
	srcset=&#34;../../p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-9_hu85371eb823b80f53d3bbcfd8dc37f4fd_178660_480x0_resize_box_3.png 480w, ../../p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-9_hu85371eb823b80f53d3bbcfd8dc37f4fd_178660_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;alt text&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;227&#34;
		data-flex-basis=&#34;545px&#34;
	
&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;第一次握手丢失了，会发生什么&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;客户端迟迟收不到服务端的 SYN-ACK 报文（第二次握手），就会触发「超时重传」机制，重传 SYN 报文，而且重传的 SYN 报文的序列号都是一样的。每次超时的时间是上一次的 2 倍。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;第二次握手丢失了&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;客户端和服务端都会重传&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;服务端那一方迟迟收不到这个ACK确认报文，就会触发超时重传机制
&lt;code&gt;(ACK 报文是不会有重传的，当 ACK 丢失了，就由对方重传对应的报文)&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;为什么挥手需要四次&#34;&gt;为什么挥手需要四次？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;关闭连接时，客户端向服务端发送 FIN 时，仅仅表示客户端不再发送数据了但是还能接收数据。&lt;/li&gt;
&lt;li&gt;服务端收到客户端的 FIN 报文时，先回一个 ACK 应答报文，而服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送 FIN 报文给客户端来表示同意现在关闭连接。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;第一次挥手丢失&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;客户端迟迟收不到被动方的 ACK 的话,触发客户端重传FIN&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;第二挥手丢失&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;服务端的第二次挥手丢失了，客户端就会触发超时重传机制,重传 FIN 报文&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;第三次挥手丢失&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;服务端就会重发 FIN 报文&lt;/p&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;第四次挥手丢失&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;客户收到FIN报文消息后，回复ACK确认消息。回复的ACK未到达服务器，服务端就会重发 FIN 报文。&lt;/p&gt;
&lt;h2 id=&#34;什么是udp&#34;&gt;什么是UDP&lt;/h2&gt;
&lt;p&gt;UDP 不提供复杂的控制机制，利用 IP 提供面向「无连接」的通信服务。DNS采用UDP协议&lt;/p&gt;
&lt;p&gt;UDP的数据格式：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-12.png&#34;
	width=&#34;783&#34;
	height=&#34;468&#34;
	srcset=&#34;../../p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-12_hucdb8ebd0ec250ba1d90fd88c9688f89c_139876_480x0_resize_box_3.png 480w, ../../p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-12_hucdb8ebd0ec250ba1d90fd88c9688f89c_139876_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;alt text&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;167&#34;
		data-flex-basis=&#34;401px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;tcp和udp的区别&#34;&gt;TCP和UDP的区别&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;连接&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;TCP是面向连接的传输层协议，传输数据前要先建立连接&lt;/li&gt;
&lt;li&gt;UDP是不需要连接，即刻传输数据&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;服务对象&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;TCP是一对一的两点服务，即一条连接只有两个端点&lt;/li&gt;
&lt;li&gt;UDP支持一对一、一对多、多对多的交互通信&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;可靠性
-TCP 是可靠交付数据的，数据可以无差错、不丢失、不重复、按序到达
-UDP是尽最大努力交付，不保证可靠交付数据。但我们可以基于UDP传输协议实现一个可靠的传输协议，比如QUIC协议。&lt;/li&gt;
&lt;li&gt;拥塞控制、流量控制&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;TCP有拥塞控制和流量控制，保证数据传输的安全性&lt;/li&gt;
&lt;li&gt;UDP则没有，即使网络非常堵了，也不会影响UDP的转发速率
5.首部开销&lt;/li&gt;
&lt;li&gt;TCP首部长度较长，会有一定的开销&lt;/li&gt;
&lt;li&gt;UDP首部只有8个字节，并且是固定不变的开销小&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;为什么需要-time_wait-状态&#34;&gt;为什么需要 TIME_WAIT 状态？&lt;/h2&gt;
&lt;p&gt;保证被关闭的一方能被正常关闭&lt;/p&gt;
&lt;h2 id=&#34;为什么-time_wait-等待的时间是-2msl&#34;&gt;为什么 TIME_WAIT 等待的时间是 2MSL&lt;/h2&gt;
&lt;p&gt;TODO&lt;/p&gt;
&lt;h2 id=&#34;服务器出现大量-close_wait-状态的原因有哪些&#34;&gt;服务器出现大量 CLOSE_WAIT 状态的原因有哪些？&lt;/h2&gt;
&lt;p&gt;当服务端出现大量 CLOSE_WAIT 状态的连接的时候，说明服务端的程序没有调用 close 函数关闭连接。&lt;/p&gt;
&lt;h2 id=&#34;服务器出现大量-time_wait-状态的原因有哪些&#34;&gt;服务器出现大量 TIME_WAIT 状态的原因有哪些？&lt;/h2&gt;
&lt;p&gt;说明服务器主动断开了很多 TCP 连接。&lt;/p&gt;
&lt;p&gt;第一个场景：HTTP 没有使用长连接&lt;br&gt;
第二个场景：HTTP 长连接超时&lt;br&gt;
第三个场景：HTTP 长连接的请求数量达到上限&lt;/p&gt;
&lt;h2 id=&#34;socket&#34;&gt;SOCKET&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;每一个socket执行listen时，内核都会自动创建一个半连接队列和全连接队列。&lt;/li&gt;
&lt;li&gt;第三次握手前，TCP连接会放在半连接队列中，直到第三次握手到来，才会被放到全连接队列中。&lt;/li&gt;
&lt;li&gt;accept方法只是为了从全连接队列中拿出一条连接，本身跟三次握手几乎毫无关系。&lt;/li&gt;
&lt;li&gt;出于效率考虑，虽然都叫队列，但半连接队列其实被设计成了哈希表，而全连接队列本质是链表。&lt;/li&gt;
&lt;li&gt;全连接队列满了，再来第三次握手也会丢弃，此时如果tcp_abort_on_overflow=1，还会直接发RST给客户端。&lt;/li&gt;
&lt;li&gt;半连接队列满了，可能是因为受到了SYN Flood攻击，可以设置tcp_syncookies，绕开半连接队列。&lt;/li&gt;
&lt;li&gt;客户端没有半连接队列和全连接队列，但有一个全局hash，可以通过它实现自连接或TCP同时打开。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;tcp-半连接和全连接队列&#34;&gt;TCP 半连接和全连接队列&lt;/h2&gt;
&lt;p&gt;在TCP三次握手的时候。Linux内核会维护两个队列，分别是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;半连接队列，也称SYN队列&lt;/li&gt;
&lt;li&gt;全连接队列,也成ACCEPT队列&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;半连接队列与全连接队列的工作流程:
&lt;img src=&#34;../../p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-13.png&#34;
	width=&#34;737&#34;
	height=&#34;519&#34;
	srcset=&#34;../../p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-13_huf74a98a048061ca50ed424c97e786bb1_148722_480x0_resize_box_3.png 480w, ../../p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-13_huf74a98a048061ca50ed424c97e786bb1_148722_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;alt text&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;142&#34;
		data-flex-basis=&#34;340px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;避免-syn-攻击方式可以有以下四种方法&#34;&gt;避免 SYN 攻击方式，可以有以下四种方法&lt;/h3&gt;
&lt;p&gt;SYN攻击是未知客户端一直向服务器发送SYN报文，将半连接队列撑满。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;增大TCP的半连接队列&lt;/li&gt;
&lt;li&gt;减少SYN+ACK的重传次数&lt;/li&gt;
&lt;li&gt;调大 netdev_max_backlog&lt;/li&gt;
&lt;li&gt;开启 tcp_syncookies&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;ip&#34;&gt;IP&lt;/h2&gt;
&lt;p&gt;IP 则负责在「没有直连」的两个网络之间进行通信传输
&lt;img src=&#34;../../p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-14.png&#34;
	width=&#34;903&#34;
	height=&#34;453&#34;
	srcset=&#34;../../p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-14_hud63107f898987fca9f53a13df30cc382_190456_480x0_resize_box_3.png 480w, ../../p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-14_hud63107f898987fca9f53a13df30cc382_190456_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;alt text&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;199&#34;
		data-flex-basis=&#34;478px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;分类&#34;&gt;分类&lt;/h3&gt;
&lt;p&gt;IP地址分为A B C D E 五大类。A、B、C 类主要分为两个部分，分别是网络号和主机号
&lt;img src=&#34;../../p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-15.png&#34;
	width=&#34;813&#34;
	height=&#34;759&#34;
	srcset=&#34;../../p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-15_hu6c7016722c1b1b13bc93afb65de498e5_283407_480x0_resize_box_3.png 480w, ../../p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-15_hu6c7016722c1b1b13bc93afb65de498e5_283407_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;alt text&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;107&#34;
		data-flex-basis=&#34;257px&#34;
	
&gt;
&lt;img src=&#34;../../p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-16.png&#34;
	width=&#34;498&#34;
	height=&#34;1173&#34;
	srcset=&#34;../../p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-16_hu139c5d424195481a8cf762a01a2d66e1_238295_480x0_resize_box_3.png 480w, ../../p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-16_hu139c5d424195481a8cf762a01a2d66e1_238295_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;alt text&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;42&#34;
		data-flex-basis=&#34;101px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;无分类地址-cidr&#34;&gt;无分类地址 CIDR&lt;/h3&gt;
&lt;p&gt;因为 IP 分类存在许多缺点，所以后面提出了无分类地址的方案，即 CIDR。&lt;br&gt;
这种方式不再有分类地址的概念，32 比特的 IP 地址被划分为两部分，前面是网络号，后面是主机号。&lt;/p&gt;
&lt;p&gt;&lt;code&gt; a.b.c.d/x，其中 /x 表示前 x 位属于网络号， x 的范围是 0 ~ 32&lt;/code&gt;
10.100.122.2/24，这种地址表示形式就是 CIDR，/24 表示前 24 位是网络号，剩余的 8 位是主机号。&lt;/p&gt;
&lt;p&gt;子网掩码:&lt;/p&gt;
&lt;p&gt;另一种划分网络号与主机号形式，那就是子网掩码，掩码的意思就是掩盖掉主机号，剩余的就是网络号。&lt;br&gt;
将子网掩码和 IP 地址按位计算 AND，就可得到网络号。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-17.png&#34;
	width=&#34;521&#34;
	height=&#34;481&#34;
	srcset=&#34;../../p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-17_hu1267da1aadaad8a095709bc02dd1552f_166566_480x0_resize_box_3.png 480w, ../../p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-17_hu1267da1aadaad8a095709bc02dd1552f_166566_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;alt text&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;108&#34;
		data-flex-basis=&#34;259px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;ip-地址与路由控制&#34;&gt;IP 地址与路由控制&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;../../p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-18.png&#34;
	width=&#34;1416&#34;
	height=&#34;902&#34;
	srcset=&#34;../../p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-18_hucd23b62d07ad2a7ae677baba820b13a8_500056_480x0_resize_box_3.png 480w, ../../p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-18_hucd23b62d07ad2a7ae677baba820b13a8_500056_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;alt text&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;156&#34;
		data-flex-basis=&#34;376px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;ping工作原理&#34;&gt;PING工作原理&lt;/h3&gt;
&lt;p&gt;ICMP: 确认 IP 包是否成功送达目标地址、报告发送过程中 IP 包被废弃的原因和改善网络设置等。
&lt;img src=&#34;../../p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-19.png&#34;
	width=&#34;1824&#34;
	height=&#34;1592&#34;
	srcset=&#34;../../p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-19_hu06751cc62f940ba7b932fb5a772a4109_218368_480x0_resize_box_3.png 480w, ../../p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-19_hu06751cc62f940ba7b932fb5a772a4109_218368_1024x0_resize_box_3.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;alt text&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;114&#34;
		data-flex-basis=&#34;274px&#34;
	
&gt;
1.客户端在网络层封装IP报文、ICMP标识为8的回送请求报文发送给指定服务器&lt;br&gt;
2.路由器接收到报文消息后先查路由表如果没有该IP指定的MAC地址&lt;br&gt;
使用ARP协议广播获取MAC地址&lt;br&gt;
3.如果能连接上就反回ICMP 为0的回复应答报文&lt;br&gt;
4.不能连接上，路由器回复ICMP 异常报文&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
